FUNCTIONAL PROGRAMMING WITH JAVA:

 
 
        repository:   https://github.com/in28minutes/functional-programming-with-java

        list.stream() 

            - returns a sequential Stream with this collection an it's source
            
            - Then you can specify what to to with each of them

            - To define the behavior, we use something called a Method Reference


                        private static void print(int number) {
                            System.out.println(number);
                        }

                        private static void printAllNumbersInListFunctional(List<Integer> numbers) {
                            numbers.stream()
                                    .forEach(FP01Functional::print);
                        }


                => For each of these elements which are coming out, we call the print method is present in the  current class.



FUNCTIONAL PROGRAMMING WITH FILTER:



                            public static void main(String[] args) {
                                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);
                               
                                printEvenNumbersInListFunctional(numbers);
                            }

                            private static boolean isEven(int number) {
                                return number%2 == 0;
                            }

                
                            private static void printEvenNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .filter(FP01Functional::isEven)
                                        .forEach(System.out::println);
                            }


                => If static method returns true back, only then go to the next line of code.



USING LAMBDA EXPRESSIONS TO ENHANCE  FUNCTIONAL PROGRAM:


        Lambda Expression 

            - Nothing but a simpler way to defining another method

                => Lambda Expression is nothing but a method.


                number -> number%2 == 0

                    - take the number and check if number%2 == 0 and return it back
                
                - By default in Lambda Expressions, if you just have one statement present, it will return
                  that value back


                            private static void printAllNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .forEach(System.out::println);
                            }

                            private static void printEvenNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .filter(number -> number%2 == 0)
                                        .forEach(System.out::println);
                            }



                    => In the Functional Programming we are focusing on what to do.

                    => A Stream is nothing but a sequenceof elements.

                    => With a Lambda Expression you can define the entire code directly in here.

                    => With a Method Reference we are actually referring to a method which is defined somewhere else.



            public class FP01Exercises {

            public static void main(String[] args) {
                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);
                List<String> courses = List.of("Spring", "Spring Boot", "API", "Microservices", "AWS",
                        "PCF", "Azure", "Docker", "Kubernetes");
                printOddNumbersInListFunctional(numbers);
                printAllCoursesIndividually(courses);
                printCoursesContainingWordSpring(courses);
                printCoursesWhoseNameAtLeast4Letters(courses);

            }

            private static void printCoursesWhoseNameAtLeast4Letters(List<String> courses) {
                courses.stream()
                        .filter(course -> course.length() >= 4)
                        .forEach(System.out::println);
            }

            private static void printCoursesContainingWordSpring(List<String> courses) {
                courses.stream()
                        .filter(course -> course.contains("Spring"))
                        .forEach(System.out::println);
            }

            private static void printAllCoursesIndividually(List<String> courses) {
                courses.stream()
                        .forEach(System.out::println);
            }

            private static void printOddNumbersInListFunctional(List<Integer> numbers) {
                numbers.stream()
                        .filter(x -> x%2 != 0)
                        .forEach(System.out::println);
            }
        }





USING MAP IN FUNCTIOAL PROGRAMS:



            private static void printSquaresOfEvenNumbersInListFunctional(List<Integer> numbers) {
            numbers.stream()
                    .filter(number -> number%2 == 0)
                    .map(number -> number * number)
                    .forEach(System.out::println);
            }

            private static void printCubesOfOddNumbersInListFunctional(List<Integer> numbers) {
                numbers.stream()
                        .filter(number -> number%2 != 0)
                        .map(number -> (int)Math.pow(number, 3))
                        .forEach(System.out::println);
            }

            private static void printNumberOfCharactersInEachCourseName(List<String> courses) {
                courses.stream()
                        .map(course -> course + " " + course.length())
                        .forEach(System.out::println);
            }




REVIEW OF  FUNCTIONAL PROGRAMMING BASICS:


        - In Functional Programming we focus on specifying what to do.

        - Stream - is a sequence of elements

        - For each element we specified what needs to be done with it.

        - Filter() allows us to specify a condition. Only if that condition is matched, then the element would go further.
          Otherwise, this element will be filtered out.

        - ForEach() is used to consume an element. For example you take an element and print it.

        - Map() - we use this to map one value to another value. 

        - Lambda Expression is nothing but a simplified representation of method.

        

STREAM OPERATIONS - REDUCE - CALCULATE SUM:


                numbers.stream().reduce(0, FP02Functional::sum)

                0 - initial value

                - and then we would specify what is the method that can be used to redue the list, using the Method Reference;


                public class FP02Functional {

                    public static void main(String[] args) {
                        List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);

                        int sum = addListFunctional(numbers);
                        System.out.println(sum);
                    }

                    public static int sum(int a, int b) {
                        return a + b;
                    }

                    public static int addListFunctional(List<Integer> numbers) {
                        // Combine them into one result => One Value
                        // 0 and (a, b) -> a + b  FP02Functional::sum
                        return  numbers.stream()
                                .reduce(0, FP02Functional::sum);   // o - initial value
                        
                    }
                }


            
            public class FP02Functional {

                public static void main(String[] args) {
                    List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);

                    int sum = addListFunctional(numbers);
                    System.out.println(sum);
                }
                
                public static int addListFunctional(List<Integer> numbers) {
                    return  numbers.stream()
                            .reduce(0, (x, y) -> x + y);     //  .reduce(Integer::sum);
                }
            }



JSHELL:


        jshell in Terminal will launch up Jshell Console


        - Find maximum:

             numbers.stream().reduce(0, (x,y) ->  x>y ? x :y)  - this logic will work foe positive numbers

        - For negative numbers too:

            numbers.stream().reduce(Integer.MIN_VALUE, (x,y) ->  x>y ? x :y)

        
        - For finding MIN value:


            numbers.stream().reduce(Integer.MAX_VALUE, (x,y) ->  x<y?x:y)




STREAM OPERATIONS - DISTINCT AND SORTED:


        Distinct:

            numbers.stream().distinct().forEach(System.out::println)  

                -excludes duplicates

        Sorted:

            numbers.stream().sorted().distinct().forEach(System.out::println)

                - will sort numbers



USING COMPARATORS TO SORT STREAMS WITH SORTED:


        courses.stream().sorted(Comparator.).forEach(System.out::println);   //for reverse order   


        - For custom compare you can define a Lambda Expression: 

        courses.stream().sorted(Comparator.comparing(str -> str.length())).forEach(System.out::println);

        - Custom Comparator with String and lambda:

            courses.stream().sorted(Comparator.comparing(x -> x.toString().length()).reversed()).forEach(System.out::println);

            courses.stream().sorted(Comparator.comparing(String::length).reversed()).forEach(System.out::println);




COLLECTING STREAM ELEMENTS USING COLLECT:


        - You can create another list, based on the current list => output is another List;


        .collect(Collectors.toList())   - collect all the resulys to a list


        Long count = numbers.stream()                        - counts elements in collection
                .map(number -> number * number)
                .count();    



        public static List<String> createListWithLengthsOfTitles(List<String> cources) {
            return cources.stream()
                    .map(course -> course + " " + course.length() + "\n")
                    .collect(Collectors.toList());
        }





STREAM OPERATIONS OVERVIEW:


        - Operations, that you can perform on a stream can be categorized into to varietes:

            - Intermediate Operations;

            - Terminal Operations;


        - All Intermediate Operations perform on a Stream and return a Stream back.

        - Terminal Operations Operations return a Specific Type.



        => So, whenever we do something with a stream, we get the Stream, perform a number of
           Intermediate Operations and then at the end, do a Terminal Operation to get the result from it
           or to do something with the elements which are present in the stream.




FUNCTIONAL INTERFACES - PREDICATE, CONSUMER, FUNCTION:


        - How are able to pass a method code to another method:

             boolean isEven(int x) {           
                return x%2 == 0;
            }

        - Lambda  x -> x%2 == o;   - is representation of this method.


        - System.out::println - is a Method Reference and it's actually simplification for a Lambda.

            (x -> System.out::println)   =   (x -> System.out.println(x))


        - What's happening in the background:

            public static void main(String[] args) {
                List<Integer> numbers = List.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

                Predicate<Integer> isEvenPredicate = x -> x%2 ==0;
                Function <Integer, Integer> squareFunction = x -> (int)Math.pow(x, 2);
                Consumer<Integer> sysoutConsumer = System.out::println;

                numbers.stream()
                        .filter(isEvenPredicate)
                        .map(squareFunction)
                        .forEach(sysoutConsumer);
            }

            => When we creating a lambda expression of this kind:

                x -> x%2 ==0
            
            - An Instance of Predicate class was being created.

            - For this specific thing, an Instance of a Function class was being created

            - How do the work:

            - Functional Interface - is something which has only one abstract method;


             Predicate<Integer> isEvenPredicate2 = new Predicate<Integer>() {
                @Override
                public boolean test(Integer x) {
                    return x%2 == 0;
                }
            };

            - What's happening:

                - In Instance of Predicate class with this specific logic is getting created for us.

                - Something similar to this is created for us and in's being used to pass this specific thing to the filter.

                - A Predicate typically used to test something. So you can see that it represents 
                  a Predicate - a Bollean-Valued Function of One Argument.

                => What id does:

                    - You pass one argument to it, the Return Type is Boolean.
                    - You can write logic around that object and return a Bollean back.

            
        FUNCTION:

            - Function<T, R> 

            - Represents a function that accepts one argument and produces a result.

            - We are taking one input and we are producing one output:

              Function<Integer, Integer> squareFunction = x -> x * x;


              Function<Integer, Integer> squareFunction = new Function<Integer, Integer>() {

                  @Override
                  public Integer apply(Integer x) {
                      return x * x;
                  }
              };



        CONSUMER:


            - It consumes whatever it gets.

            - Represents an operation that acepts a single input argument and returns no result.

            - Consumer<T>

              Consumer<Integer> sysoutConsumer = System.out::println; 

              Consumer<Integer> sysoutConsumer = new Consumer<Integer>

            - void accept(T t) - performs operation on the given argument;


            Consumer<Integer> sysoutConsumer = System.out::println;

            Consumer<Integer> sysoutConsumer = new Consumer<Integer>() {
                
                @Overridepublic void accept(Integer x) {
                    
                    System.oot.println(x);
                }
            };


        - Behind each Lambda Experssion that we write is something called a Functional Interface;

        - One which is used when we are using filter(). It's a Predicate;
          So, with a filter we are defining a condition, we take a input and return back boolean;

        - Map() is actually take a input and customizes it and returns an output.
          So, you have one input and one output and that's where we use a Function;

        - And forEach() ia a Consumer - it takes the input and it consumes it.

            
        - Typically, Abstract Method is called a Function Descriptor;



BEHAVIOR PARAMETERIZATION:


        Prediate<Integer> isEvenPredicate = x -> x%2 == 0;  

        x -> x%2 == 0    -  is the Behavior of this specific Method.

        - Here we're taking the behavior of the method and actually putting it into a Variable.

        - Can we use this and pass this as an argument to another method? 

        - Can we create a Custom Method like that?



            public class FP03BehaviorParameterization {

                @SuppressWarnings("unused")
                public static void main(String[] args) {
                    List<Integer> numbers = List.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

                    Predicate<Integer> evenPredicate = x -> x % 2 == 0;
                    filterAndPrint(numbers, evenPredicate);

                    Predicate<Integer> oddPredicate = x -> x % 2 != 0;
                    filterAndPrint(numbers, oddPredicate);
                }

                private static void filterAndPrint(List<Integer> numbers, Predicate<Integer> predicate) {
                    numbers.stream()
                            .filter(predicate)
                            .forEach(System.out::println);
                }
            }  


            
            - We are passing the predicate as another argument. so we can pass in whether I would want to print even numbers
              or odd numbers as a argument to this particular method and you see that that is wahat is being  used to filter in here.

            - Now I'll do a inline variable to inline the evenPredicate.

            - So, what we are doing:

                - We are passing the logic of the method as an argument of the method, we are passing the behavior of the
                  method as an argument.

                - And this is what is called Behavior Parameterization;

                - We are passing an algorithm, the strategy, as a parameter. 

                - And this would provide a lot of flexibility in how we code.




        public class FP03Exercises {                                                                                                                
                                                                                                                                            
            public static void main(String[] args) {                                                                                                
                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);                                                                    
                List<String> courses = List.of("Spring", "Spring Boot", "API", "Microservices", "AWS",                                              
                        "PCF", "Azure", "Docker", "Kubernetes");                                                                                    
                                                                                                                                                    
                Integer sum = fiml(numbers);                                                                                                        
                System.out.println(sum);                                                                                                            
                                                                                                                                                    
                List<Integer> squaredNumbers = mapAndCreateNewList(numbers, x -> x * x);                                                            
                                                                                                                                                    
                List<Integer> cubeNumbers = mapAndCreateNewList(numbers, x -> (int)Math.pow(x, 3));                                                 
                                                                                                                                                    
                List<Integer> doubleNumbers = mapAndCreateNewList(numbers, x -> x + x);                                                             
                                                                                                                                                    
                System.out.println(squaredNumbers);                                                                                                 
                System.out.println(cubeNumbers);                                                                                                    
                System.out.println(doubleNumbers);                                                                                                  
            }                                                                                                                                       
                                                                                                                                                    
            private static List<Integer> mapAndCreateNewList(List<Integer> numbers, Function<Integer, Integer> mappingFunction) {                   
                return numbers.stream()                                                                                                             
                                .map(mappingFunction)                                                                                               
                                .collect(Collectors.toList());                                                                                      
            }         




SUPPLIER  AND UNARY OPERATOR FUNCTIONAL INTERFACES:


        Function<Integer, String> stringOutputFunction = x -> x + " ";    - will return String

        BinaryOperator<Integer> sumBinaryOperator = (x, y) -> x + y;

        Supplier:

            - Is a situation where you don't have any input. So, you don't have any parameters as input and we would
              want to return something back. For example a Factory Pattern.


        Supplier<Integer> randomIntegerSupplier =  () -> 2;

        - Supplier has one abstract method get()    


        Returning random set of values:


              Supplier<Integer> randomIntegerSupplier = () -> {
                Random random  = new Random();
                return random.nextInt(1000);
            };
            System.out.println(randomIntegerSupplier.get());




        UnaryOperator:

            - Unary Operator will actually take one parameter as the input  and returns the result of the same type as the output;


            UnaryOperator<Integer> unaryOperator = (x) 3 * x;

            - Unary Operator has one abstract method apply();




BIPREDICATE, BIFUNCTION, BICONSUMER AND PRIMITIVE FUNCTION: 


    BiPredicate:

        - We have 2 inputs to your lambda expression and we would want to return boolean;

        - Has one abstract method test();


        BiPredicate<Integer, String> biPredicate = (number, str) -> number < 10 && str.length() > 5;

        System.out.println(biPredicate.test(7, "testString"));


    BiFunction:

        - Takes 2 inputs and return 1 value back;

        - You need to specify a Return Type;

        - Has 1 abstract method apply();




        BiFunction<Integer, String, String> biFunction = (number, str) -> number + " " +  str;

        System.out.println(biFunction.apply(7, "test"));


    BiConsumer:

        - BiConsumer takes 2 inputs and it consumes it, does not return anything back;

        - Has 1 abstract method accept();


        BiConsumer<String, String> biConsumer = (s1, s2) -> {
            System.out.println(s1);
            System.out.println(s2);
        };

        biConsumer.accept("15", "in28minutes");




    => When you create Lambda Expression, you can use this specific interfaces to represent that specific Lambda Expression;


    
    PrimitiveFunctional:

        - IntBinaryOperator

        - IntConsumer

        - IntFunction 

        - IntPredicate

        - IntSupplier 

        - IntToDoubleFunction

        - IntToLongFunction

        - IntUnaryOperator



        IntToDoubleFunction intToDoubleFunction = (x) -> x;

        System.out.println(intToDoubleFunction.applyAsDouble(5));


        - An important thing is, wherenever we are doing things with wrapper classes, boxing and unboxing comes 
          into picture and that's's inefficient (неэффективно). 

        - So, if you have a set of primitives and you'd want to play around them using Lambda Expressions,
          it's better to use Primitive Lambda Expressions;


        => Important thing that now all the operations are Primitive Operations, so there is no chance of boxing,
           auto-boxing, and all those performance kind of issues coming in;

        - Inside the List we can only have Wrapper-class elements or Wrapper-class Objects.

        - Whenever you're playing with Primitives, you should prefer the Primitive Operations.




METHOD REFERENCES:


        List<String> courses = List.of("Spring", "Spring Boot", "API",
                "Microservices", "AWS", "PCF", "Azure",
                "Docker", "Kubernetes");

        courses.stream()
                .map(String::toUpperCase)
                .forEach(System.out::println);


        
        -  For each elements inside the stream, the System.out.println would be called with that specific element passed 
           as a parameter.


        - We also saw the fact that we can actually create a static method in here and call it also from here:


            public class FP03MethodReferences {

                @SuppressWarnings("unused")
                public static void main(String[] args) {

                    List<String> courses = List.of("Spring", "Spring Boot", "API",
                            "Microservices", "AWS", "PCF", "Azure",
                            "Docker", "Kubernetes");

                    courses.stream()
                            .map(String::toUpperCase)
                            .forEach(FP03MethodReferences::print);
                }
                
                private static void print(String str) {
                    System.out.println(str);
                }
            }



        - The Interesting thing that you can also use Method References to call things on a specific object;

        - Also you can use Method References for Constructor References:


            Supplier<String>  supplier  =  ()  -> new String();

                        <=>

             Supplier<String>  supplier  = String::new;


        - You can use this to create new Objects;




ALLMATCH, NONEMATCH, ANYMATCH:


        - We want to ind out, if all the courses have a review score greater than 90:


            Predicate<Course> reviewScoreGreaterThan95Predicate = course -> course.getReviewScore() > 95;

            Predicate<Course> reviewScoreGreaterThan90Predicate = course -> course.getReviewScore() > 90;

            Predicate<Course> reviewScoreLessThan90Predicate = course -> course.getReviewScore() < 90;

            System.out.println(courses.stream()
                    .allMatch(reviewScoreGreaterThan90Predicate));

            System.out.println(courses.stream()
                    .noneMatch(reviewScoreGreaterThan95Predicate));

            System.out.println(courses.stream()
                    .noneMatch(reviewScoreLessThan90Predicate));

            System.out.println(courses.stream()
                    .anyMatch(reviewScoreGreaterThan90Predicate));


        - allMatch() returns a true, if every element in this stream matches the condition;

        - noneMatch() returns true, if no elements in the stream matches this condition;

        - anyMatch() returns true, if at least one element in the stream matches that specific condition;




SORTING. CREATING COMPARATORS:


        - For sorting stream we need sorted() and pass in a Comparator:


                Comparator<Course> comparingByNumberOfStudents = Comparator.comparing(Course::getNumberOfStudents);

                System.out.println(courses.stream()
                        .sorted(comparingByNumberOfStudents)
                        .collect(Collectors.toList()));


        - Comparing by Number Of Students Deceasing using reversed() and using no-aitoboxing primitive Comparing:


                Comparator<Course> comparingByNoOfStudentsDecreasing = Comparator.comparingInt(Course::getNumberOfStudents).reversed();

                System.out.println(courses.stream()
                .sorted(comparingByNoOfStudentsDecreasing)
                .collect(Collectors.toList()));


        - If Course has the same number of Students use thenComparing():


                Comparator<Course>  comparingByNumberOfStudentsAndReviews = Comparator.comparing(Course::getNumberOfStudents)
                        .thenComparing(Course::getReviewScore)
                        .reversed();

                System.out.println(courses.stream()
                        .sorted(comparingByNumberOfStudentsAndReviews)
                        .collect(Collectors.toList()));




SKIP, LIMIT, TAKEWHILE, DROPWHILE:



        - Let's say, I don't want a complete List of Courses, so here, when I do a sort, I want to pick up only
          the first five, the top 5 courses:

        - The way I can do that is by using a Limit - I can take only first 5 results:


              System.out.println(courses.stream()
                .sorted(comparingByNumberOfStudentsAndReviews)
                .limit(5)
                .collect(Collectors.toList()));

        
        - Let's say I would want to skip top 3 results:


              System.out.println(courses.stream()
                .sorted(comparingByNumberOfStudentsAndReviews)
                .skip(3)
                .collect(Collectors.toList()));


        - Let's say I would want to take all elements until I find an element which is having a Review Score less than 95.
          So, I would want to keep checking the list until I find a Course with Review Score less than 95 and as soon as I find it, I'd
          want to return this stuff which I found earlier:


                System.out.println(courses.stream()
                    .takeWhile(course ->  course.getReviewScore() >= 95)
                    .collect(Collectors.toList()));


        - DropWhile() will keep cheking if this condition is true.
          If condition is true - it will skip the elements:


                 System.out.println(courses.stream()
                    .dropWhile(course ->  course.getReviewScore() >= 95)
                    .collect(Collectors.toList()));




MAX, MIN, FINDFIRST, FINDANY:


        - Find the Max course defined by criteria:

                System.out.println(courses.stream()
                    .max(comparingByNumberOfStudentsAndReviews));

                result is:

                    Optional[FullStack:14000:91]

                - Here MAX - is the Last element of the list, it does not whether it's a higher value or lesser value,
                  using this criteria of comparsion.


        - MIN returns the first element:

                 System.out.println(courses.stream()
                    min(comparingByNumberOfStudentsAndReviews));


        - What is Optional Stuff in here:

                - if no result it will return Optional.empty

                - Optional is a wat to get around NulPointerExceptions:

                    - So, instead of returning a null back, you can return Optional.empty back

                - Optional allows you to specify a default value.


                    System.out.println(courses.stream()
                        .min(comparingByNumberOfStudentsAndReviews)
                        .orElse(new Course("Kubernetes", "Cloud", 91, 20000)));


                - Here if it does not find any minimum value, it would return this value back,
                  so, we are not really returning a null or something of that kind back;


            => Optional provides you a way to check if a result exists or not


        - FIND FIRST element which meets a certain criteria:

            - findFirst() returns n Optional back;System.out.println(courses.stream()
                .filter(reviewScoreLessThan90Predicate)
                .findFirst());


        - FIND ANY:

            - findAny() atually returns any of the values, any of the elements from stream, which match this criteria.




SUM, AVERAGE, COUNT:


        -  We want to find average number of students for courses which have reviews greater than a specific value:


                System.out.println(courses.stream()
                    .filter(reviewScoreGreaterThan90Predicate)
                    .mapToInt(Course::getNumberOfStudents)
                    .average());


                System.out.println(courses.stream()
                    .filter(reviewScoreGreaterThan90Predicate)
                    .mapToInt(Course::getNumberOfStudents)
                    .sum());


            - .sum() would give the total number of students who are in courses which have review score greater than 90.


        - How many courses met the criteria:


                  System.out.println(courses.stream()
                    .filter(reviewScoreGreaterThan90Predicate)
                    .mapToInt(Course::getNumberOfStudents)
                    .count());
        
        
        - Course with the MAX number of students:


                System.out.println(courses.stream()
                    .filter(reviewScoreGreaterThan90Predicate)
                    .mapToInt(Course::getNumberOfStudents)
                    .max());




GROUPING COURSES TO A MAP USING GROUPINGBY:


        - I want to group courses based on the category:

        - I want to create HashMap, where the framework is the Key and these two courses as the values present against it;

        - I need to define a Collectors:


                System.out.println(courses.stream()
                    .collect(Collectors.groupingBy(Course::getCategory)));


                - Output:


                        {Cloud=[AWS:21000:92, Azure:21000:99, Docker:21000:92, Kubernetes:20000:91],
                        FullStack=[FullStack:14000:91], Microservices=[API:22000:97, Microservices:25000:96], 
                        Framework=[Spring:20000:98, Spring Boot:18000:95]}


        - I want to find how many FullStack Courses, how many CLoud Courses etc:


                System.out.println(courses.stream()
                    .collect(Collectors.groupingBy(Course::getCategory, Collectors.counting())));


                - Output:


                        {Cloud=4, FullStack=1, Microservices=2, Framework=2}


        - Among 4 Course , whichever one is the highest reviewed Course:
                        

                  System.out.println(courses.stream()
                        .collect(Collectors.groupingBy(
                            Course::getCategory, Collectors.maxBy(Comparator.comparing(Course::getReviewScore)))));


                - Output:


                        {Cloud=Optional[Azure:21000:99], FullStack=Optional[FullStack:14000:91],
                         Microservices=Optional[API:22000:97], Framework=Optional[Spring:20000:98]}


        - Instead of mapping a complete Course, ust map the name of the Course,
          So, instead of mapping the entire Course to that specific list,
          we would want to create a list just with names of the course:

            Collectors.mapping(mapper, downstream)

                - Here we need to define what do we want to use:



                
CREATING A STREAMS USING STREAM OF METHOD AND FOR ARRAYS:

        - Until now to create a Stream  we created  a List and we created a Stream from it:


                List<Integer> numbers = List.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

                numbers.stream();


        - Another option is Stream.of(): 


                Stream.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

        
                Stream<Integer> stream = Stream.of(12, 9, 13, 4, 6, 2, 4, 12, 15);
                System.out.println(stream.count());
                Stream<Integer> stream1 = Stream.of(12, 9, 13, 4, 6, 2, 4, 12, 15);
                System.out.println(stream1.reduce(0, Integer::sum));
            


        - Streams with Primitive Values:


                int[]  numberArray = {12, 9, 13, 4, 6, 2, 4, 12, 15};

                Arrays.stream(numberArray);

                    - This is Stream of Primitive Types, can use sum, average...

                System.out.println(Arrays.stream(numberArray).sum());
                System.out.println(Arrays.stream(numberArray).average());

                IntStream intStream = Arrays.stream(numberArray);
                intStream.sum();
        

        - Both the Streams contains elements of Integer wrapper classes.

        - To create Stresm with Primitive Values, there are options:

            - Use  array as source to create a stream (IntPipeline is the Type of Stream) and
              with this way we can very easy to do a sum, average, min, max anf those kinf ofoperations



CREATING STREAMS FOR FIRST 100 NUMBERS. SQUARES OF NUMBERS AND MORE:


        - How to createa stream of primitive values much more dynamically:

        - I would want to create a stream with the first hundres Integers or I'd want to create a stream with just 
          even numbers or odd numbers or I'd want to use a speific algorithm to create a stream. 


                IntStream.range(1, 10).sum()    

                    - the range() operation excludes the last number;

                System.out.println(IntStream.rangeClosed(1, 10).sum());

                    - the rangeClosed() includes the last number;


        - The peek() method will allow us to look into this Stream without making any changes to the actual Stream,
          so I can try to print all the values that are part of the Stream:

        - iterate() for making custom algorithm;
        
            IntStream.iterate(1, e -> e + 2).limit(10).peek(System.out::println).sum();

            System.out.println(IntStream.iterate(1, e -> e + 2).limit(10).peek(System.out::println).sum());


        - print first Even numbers with SOUT and print their SUM:

                System.out.println(IntStream.iterate(2, e -> e + 2).limit(10).peek(System.out::println).sum());

        - print powers of 2 - limit 10:

                System.out.println(IntStream.iterate(1, e -> (int)Math.pow(2, e)).limit(10).peek(System.out::println).sum());

                or:

                System.out.println(IntStream.iterate(2, e -> e * 2).limit(10).peek(System.out::println).sum()); 


        - If you'd want to convert Primitive Stream into a List, there is a specific thing, that you need to understand:

            - Before we actuaaly apply a collect()  to a primitive streams, we need to do something called a Boxed Operation:

                IntStream.iterate(2, e -> e * 2).limit(10)
                .boxed()
                .collect(Collectors.toList());

            - This is because the values in the stream are primitive. 

            - We need to box them into actually a Wrapper Class before we actually collect them to a list.


        - Just like IntStream there are interfaces like  DoubleStream, LongStream , which would help you with creating streams of
          primitive values for double, int , long.



BIG NUMBER CALCULATION WITH BIG INTEGER:


        - How actually do calculations with really BIG values:


                    IntStream.rangeClosed(1, 50).reduce(1 , (x, y) -> x * y);
        

        - Here the result will be 0, because the result exceeds the Integer Max value;

        - In this kind of situation we can use of something called Big Integer:

                IntStream.rangeClosed(1, 50)
                    .mapToObj(BigInteger::valueOf)
                    .reduce(BigInteger.ONE , BigInteger::multiply);



JOINING STRINGS, FLATMAP:


        - Let's say I have a List of Strings - List Of Course Names. And I want to combine all of them,
          separated by a comma.

        - I need collect(Collectors.joining(" "))    - and pass in the separator:


                courses.stream()
                    .collect(Collectors.joining(", ")));


        - I need to look at all the characters which are present in each one of these strings:


                Arrays.toString("Spring".split(""))    -  array with individual characters

        - flatMap() - we are flatting the array of strings and now, at the end of operation, we have one stream with all individual
          strings, all strings containing one character each, and now I can do collect(Collectors.toList())


                courses.stream()
                    .map(course -> course.split(""))
                    .flatMap(Arrays::stream)
                    .collect(Collectors.toList())


        - Let's say I'd want only the distinct characters:


                courses.stream()
                    .map(course -> course.split(""))
                    .flatMap(Arrays::stream)
                    .distinct()
                    .collect(Collectors.toList())


                => now we get all the distinct characters which a present in our course title.


        - In Java Doc for the flatMap() operation, it says:

            "Returns a stream consisting of the results of replacing each element of the stream with the contents 
             of a mapped stream provided by applying the provided Mapping Function to each element"

            - Возвращает стрим, содержащий результаты замены каждого элемента стрима содержимым замапленного стрима,
              предоставленные применением Функции Отобраения к каждому элементу.


            - The result we got from the map operation was a Stream of String Arrays.

            - What we want to do - we want to flatting the String Arrays and we would want ti create a Stream of Strings.

            - Each of the String Arrays which were present in the Stream, we wanted to flatting  it out and that's where
            the flapMap() helps us.


        - Another case is - we have the list of Courses and overe here, you an see that  there are a few elements 
          with the same number of characters.

          => We'd want to identify pairs of these Courses which have the same number of Characters present in them.

            => All the Strinsg which have the same length.

            - What we are doing - We taking each of the Course from the List and trying to map with each of the courses in this
              specific list and we are creating a List out of it. 

            - And then we would want to cllet them into a single List.

                    courses.stream()
                        .flatMap(
                                course -> courses2.stream()
                                        .map(course2 -> List.of(course, course2)))
                        .collect(Collectors.toList());

                
                =>  As result - we joined each of the elements  in the First List with each of the elements in the Second List.

                    => It's like a Matrix

                    => You can see that eah element  of the Stream is a List of Two Elements.


            - And now I'd want to look out for elements which have the same length.

                - One the important things to note is that, if I do length of Spring and the length of Spring here,
                  it would return the same thing. 

                    => Spring, Spring;   Spring Boot, Spriing Boot...

                        - all those elements would come by default. And we don't want them at all.

                        => What we can do - try to filter them:


                        => So, I'll go here and actually first try and filter out the elements where both 
                           the elements are the same.

                           - So, we'd want to filter out  those things where both list dot  first element and list dot
                             seond element.

                            - List dot element at index 0 and List dot element at index 1 are the same.

                            - How can we do a Filter:

                            => Take  the List and check if list.get(0) equals list.get(1)


                            System.out.println(
                                    courses.stream()
                                            .flatMap(
                                                    course -> courses2.stream()
                                                            .map(course2 -> List.of(course, course2)))
                                            .filter(list -> !list.get(0).equals(list.get(1)))
                                            .collect(Collectors.toList())
                            );

            - The next thing - is a filter based on the Length.


                    courses.stream()
                        .flatMap(
                                course -> courses2.stream()
                                        .filter(course2 -> course2.length()  == course.length() )
                                        .map(course2 -> List.of(course, course2)))
                        .filter(list -> !list.get(0).equals(list.get(1)))
                        .collect(Collectors.toList())



        => FlatMap helps us in Flatting a Stream of Values.

            - So, if you have a Stream of String Arrays, you can flatting it into a Ztream of Strings.






