FUNCTIONAL PROGRAMMING WITH JAVA:

 
 
        repository:   https://github.com/in28minutes/functional-programming-with-java

        list.stream() 

            - returns a sequential Stream with this collection an it's source
            
            - Then you can specify what to to with each of them

            - To define the behavior, we use something called a Method Reference


                        private static void print(int number) {
                            System.out.println(number);
                        }

                        private static void printAllNumbersInListFunctional(List<Integer> numbers) {
                            numbers.stream()
                                    .forEach(FP01Functional::print);
                        }


                => For each of these elements which are coming out, we call the print method is present in the  current class.



FUNCTIONAL PROGRAMMING WITH FILTER:



                            public static void main(String[] args) {
                                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);
                               
                                printEvenNumbersInListFunctional(numbers);
                            }

                            private static boolean isEven(int number) {
                                return number%2 == 0;
                            }

                
                            private static void printEvenNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .filter(FP01Functional::isEven)
                                        .forEach(System.out::println);
                            }


                => If static method returns true back, only then go to the next line of code.



USING LAMBDA EXPRESSIONS TO ENHANCE  FUNCTIONAL PROGRAM:


        Lambda Expression 

            - Nothing but a simpler way to defining another method

                => Lambda Expression is nothing but a method.


                number -> number%2 == 0

                    - take the number and check if number%2 == 0 and return it back
                
                - By default in Lambda Expressions, if you just have one statement present, it will return
                  that value back


                            private static void printAllNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .forEach(System.out::println);
                            }

                            private static void printEvenNumbersInListFunctional(List<Integer> numbers) {
                                numbers.stream()
                                        .filter(number -> number%2 == 0)
                                        .forEach(System.out::println);
                            }



                    => In the Functional Programming we are focusing on what to do.

                    => A Stream is nothing but a sequenceof elements.

                    => With a Lambda Expression you can define the entire code directly in here.

                    => With a Method Reference we are actually referring to a method which is defined somewhere else.



            public class FP01Exercises {

            public static void main(String[] args) {
                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);
                List<String> courses = List.of("Spring", "Spring Boot", "API", "Microservices", "AWS",
                        "PCF", "Azure", "Docker", "Kubernetes");
                printOddNumbersInListFunctional(numbers);
                printAllCoursesIndividually(courses);
                printCoursesContainingWordSpring(courses);
                printCoursesWhoseNameAtLeast4Letters(courses);

            }

            private static void printCoursesWhoseNameAtLeast4Letters(List<String> courses) {
                courses.stream()
                        .filter(course -> course.length() >= 4)
                        .forEach(System.out::println);
            }

            private static void printCoursesContainingWordSpring(List<String> courses) {
                courses.stream()
                        .filter(course -> course.contains("Spring"))
                        .forEach(System.out::println);
            }

            private static void printAllCoursesIndividually(List<String> courses) {
                courses.stream()
                        .forEach(System.out::println);
            }

            private static void printOddNumbersInListFunctional(List<Integer> numbers) {
                numbers.stream()
                        .filter(x -> x%2 != 0)
                        .forEach(System.out::println);
            }
        }





USING MAP IN FUNCTIOAL PROGRAMS:



            private static void printSquaresOfEvenNumbersInListFunctional(List<Integer> numbers) {
            numbers.stream()
                    .filter(number -> number%2 == 0)
                    .map(number -> number * number)
                    .forEach(System.out::println);
            }

            private static void printCubesOfOddNumbersInListFunctional(List<Integer> numbers) {
                numbers.stream()
                        .filter(number -> number%2 != 0)
                        .map(number -> (int)Math.pow(number, 3))
                        .forEach(System.out::println);
            }

            private static void printNumberOfCharactersInEachCourseName(List<String> courses) {
                courses.stream()
                        .map(course -> course + " " + course.length())
                        .forEach(System.out::println);
            }




REVIEW OF  FUNCTIONAL PROGRAMMING BASICS:


        - In Functional Programming we focus on specifying what to do.

        - Stream - is a sequence of elements

        - For each element we specified what needs to be done with it.

        - Filter() allows us to specify a condition. Only if that condition is matched, then the element would go further.
          Otherwise, this element will be filtered out.

        - ForEach() is used to consume an element. For example you take an element and print it.

        - Map() - we use this to map one value to another value. 

        - Lambda Expression is nothing but a simplified representation of method.

        

STREAM OPERATIONS - REDUCE - CALCULATE SUM:


                numbers.stream().reduce(0, FP02Functional::sum)

                0 - initial value

                - and then we would specify what is the method that can be used to redue the list, using the Method Reference;


                public class FP02Functional {

                    public static void main(String[] args) {
                        List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);

                        int sum = addListFunctional(numbers);
                        System.out.println(sum);
                    }

                    public static int sum(int a, int b) {
                        return a + b;
                    }

                    public static int addListFunctional(List<Integer> numbers) {
                        // Combine them into one result => One Value
                        // 0 and (a, b) -> a + b  FP02Functional::sum
                        return  numbers.stream()
                                .reduce(0, FP02Functional::sum);   // o - initial value
                        
                    }
                }


            
            public class FP02Functional {

                public static void main(String[] args) {
                    List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);

                    int sum = addListFunctional(numbers);
                    System.out.println(sum);
                }
                
                public static int addListFunctional(List<Integer> numbers) {
                    return  numbers.stream()
                            .reduce(0, (x, y) -> x + y);     //  .reduce(Integer::sum);
                }
            }



JSHELL:


        jshell in Terminal will launch up Jshell Console


        - Find maximum:

             numbers.stream().reduce(0, (x,y) ->  x>y ? x :y)  - this logic will work foe positive numbers

        - For negative numbers too:

            numbers.stream().reduce(Integer.MIN_VALUE, (x,y) ->  x>y ? x :y)

        
        - For finding MIN value:


            numbers.stream().reduce(Integer.MAX_VALUE, (x,y) ->  x<y?x:y)




STREAM OPERATIONS - DISTINCT AND SORTED:


        Distinct:

            numbers.stream().distinct().forEach(System.out::println)  

                -excludes duplicates

        Sorted:

            numbers.stream().sorted().distinct().forEach(System.out::println)

                - will sort numbers



USING COMPARATORS TO SORT STREAMS WITH SORTED:


        courses.stream().sorted(Comparator.).forEach(System.out::println);   //for reverse order   


        - For custom compare you can define a Lambda Expression: 

        courses.stream().sorted(Comparator.comparing(str -> str.length())).forEach(System.out::println);

        - Custom Comparator with String and lambda:

            courses.stream().sorted(Comparator.comparing(x -> x.toString().length()).reversed()).forEach(System.out::println);

            courses.stream().sorted(Comparator.comparing(String::length).reversed()).forEach(System.out::println);




COLLECTING STREAM ELEMENTS USING COLLECT:


        - You can create another list, based on the current list => output is another List;


        .collect(Collectors.toList())   - collect all the resulys to a list


        Long count = numbers.stream()                        - counts elements in collection
                .map(number -> number * number)
                .count();    



        public static List<String> createListWithLengthsOfTitles(List<String> cources) {
            return cources.stream()
                    .map(course -> course + " " + course.length() + "\n")
                    .collect(Collectors.toList());
        }





STREAM OPERATIONS OVERVIEW:


        - Operations, that you can perform on a stream can be categorized into to varietes:

            - Intermediate Operations;

            - Terminal Operations;


        - All Intermediate Operations perform on a Stream and return a Stream back.

        - Terminal Operations Operations return a Specific Type.



        => So, whenever we do something with a stream, we get the Stream, perform a number of
           Intermediate Operations and then at the end, do a Terminal Operation to get the result from it
           or to do something with the elements which are present in the stream.




FUNCTIONAL INTERFACES - PREDICATE, CONSUMER, FUNCTION:


        - How are able to pass a method code to another method:

             boolean isEven(int x) {           
                return x%2 == 0;
            }

        - Lambda  x -> x%2 == o;   - is representation of this method.


        - System.out::println - is a Method Reference and it's actually simplification for a Lambda.

            (x -> System.out::println)   =   (x -> System.out.println(x))


        - What's happening in the background:

            public static void main(String[] args) {
                List<Integer> numbers = List.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

                Predicate<Integer> isEvenPredicate = x -> x%2 ==0;
                Function <Integer, Integer> squareFunction = x -> (int)Math.pow(x, 2);
                Consumer<Integer> sysoutConsumer = System.out::println;

                numbers.stream()
                        .filter(isEvenPredicate)
                        .map(squareFunction)
                        .forEach(sysoutConsumer);
            }

            => When we creating a lambda expression of this kind:

                x -> x%2 ==0
            
            - An Instance of Predicate class was being created.

            - For this specific thing, an Instance of a Function class was being created

            - How do the work:

            - Functional Interface - is something which has only one abstract method;


             Predicate<Integer> isEvenPredicate2 = new Predicate<Integer>() {
                @Override
                public boolean test(Integer x) {
                    return x%2 == 0;
                }
            };

            - What's happening:

                - In Instance of Predicate class with this specific logic is getting created for us.

                - Something similar to this is created for us and in's being used to pass this specific thing to the filter.

                - A Predicate typically used to test something. So you can see that it represents 
                  a Predicate - a Bollean-Valued Function of One Argument.

                => What id does:

                    - You pass one argument to it, the Return Type is Boolean.
                    - You can write logic around that object and return a Bollean back.

            
        FUNCTION:

            - Function<T, R> 

            - Represents a function that accepts one argument and produces a result.

            - We are taking one input and we are producing one output:

              Function<Integer, Integer> squareFunction = x -> x * x;


              Function<Integer, Integer> squareFunction = new Function<Integer, Integer>() {

                  @Override
                  public Integer apply(Integer x) {
                      return x * x;
                  }
              };



        CONSUMER:


            - It consumes whatever it gets.

            - Represents an operation that acepts a single input argument and returns no result.

            - Consumer<T>

              Consumer<Integer> sysoutConsumer = System.out::println; 

              Consumer<Integer> sysoutConsumer = new Consumer<Integer>

            - void accept(T t) - performs operation on the given argument;


            Consumer<Integer> sysoutConsumer = System.out::println;

            Consumer<Integer> sysoutConsumer = new Consumer<Integer>() {
                
                @Overridepublic void accept(Integer x) {
                    
                    System.oot.println(x);
                }
            };


        - Behind each Lambda Experssion that we write is something called a Functional Interface;

        - One which is used when we are using filter(). It's a Predicate;
          So, with a filter we are defining a condition, we take a input and return back boolean;

        - Map() is actually take a input and customizes it and returns an output.
          So, you have one input and one output and that's where we use a Function;

        - And forEach() ia a Consumer - it takes the input and it consumes it.

            
        - Typically, Abstract Method is called a Function Descriptor;



BEHAVIOR PARAMETERIZATION:


        Prediate<Integer> isEvenPredicate = x -> x%2 == 0;  

        x -> x%2 == 0    -  is the Behavior of this specific Method.

        - Here we're taking the behavior of the method and actually putting it into a Variable.

        - Can we use this and pass this as an argument to another method? 

        - Can we create a Custom Method like that?



            public class FP03BehaviorParameterization {

                @SuppressWarnings("unused")
                public static void main(String[] args) {
                    List<Integer> numbers = List.of(12, 9, 13, 4, 6, 2, 4, 12, 15);

                    Predicate<Integer> evenPredicate = x -> x % 2 == 0;
                    filterAndPrint(numbers, evenPredicate);

                    Predicate<Integer> oddPredicate = x -> x % 2 != 0;
                    filterAndPrint(numbers, oddPredicate);
                }

                private static void filterAndPrint(List<Integer> numbers, Predicate<Integer> predicate) {
                    numbers.stream()
                            .filter(predicate)
                            .forEach(System.out::println);
                }
            }  


            
            - We are passing the predicate as another argument. so we can pass in whether I would want to print even numbers
              or odd numbers as a argument to this particular method and you see that that is wahat is being  used to filter in here.

            - Now I'll do a inline variable to inline the evenPredicate.

            - So, what we are doing:

                - We are passing the logic of the method as an argument of the method, we are passing the behavior of the
                  method as an argument.

                - And this is what is called Behavior Parameterization;

                - We are passing an algorithm, the strategy, as a parameter. 

                - And this would provide a lot of flexibility in how we code.




        public class FP03Exercises {                                                                                                                
                                                                                                                                            
            public static void main(String[] args) {                                                                                                
                List<Integer> numbers = List.of(12, 9 , 13, 4, 6, 2, 4, 12, 15);                                                                    
                List<String> courses = List.of("Spring", "Spring Boot", "API", "Microservices", "AWS",                                              
                        "PCF", "Azure", "Docker", "Kubernetes");                                                                                    
                                                                                                                                                    
                Integer sum = fiml(numbers);                                                                                                        
                System.out.println(sum);                                                                                                            
                                                                                                                                                    
                List<Integer> squaredNumbers = mapAndCreateNewList(numbers, x -> x * x);                                                            
                                                                                                                                                    
                List<Integer> cubeNumbers = mapAndCreateNewList(numbers, x -> (int)Math.pow(x, 3));                                                 
                                                                                                                                                    
                List<Integer> doubleNumbers = mapAndCreateNewList(numbers, x -> x + x);                                                             
                                                                                                                                                    
                System.out.println(squaredNumbers);                                                                                                 
                System.out.println(cubeNumbers);                                                                                                    
                System.out.println(doubleNumbers);                                                                                                  
            }                                                                                                                                       
                                                                                                                                                    
            private static List<Integer> mapAndCreateNewList(List<Integer> numbers, Function<Integer, Integer> mappingFunction) {                   
                return numbers.stream()                                                                                                             
                                .map(mappingFunction)                                                                                               
                                .collect(Collectors.toList());                                                                                      
            }         




SUPPLIER  AND UNARY OPERATOR FUNCTIONAL INTERFACES:


        Function<Integer, String> stringOutputFunction = x -> x + " ";    - will return String

        BinaryOperator<Integer> sumBinaryOperator = (x, y) -> x + y;

        Supplier:

            - Is a situation where you don't have any input. So, you don't have any parameters as input and we would
              want to return something back. For example a Factory Pattern.


        Supplier<Integer> randomIntegerSupplier =  () -> 2;

        - Supplier has one abstract method get()    


        Returning random set of values:


              Supplier<Integer> randomIntegerSupplier = () -> {
                Random random  = new Random();
                return random.nextInt(1000);
            };
            System.out.println(randomIntegerSupplier.get());




        UnaryOperator:

            - Unary Operator will actually take one parameter as the input  and returns the result of the same type as the output;


            UnaryOperator<Integer> unaryOperator = (x) 3 * x;

            - Unary Operator has one abstract method apply();




BIPREDICATE, BIFUNCTION, BICONSUMER AND PRIMITIVE FUNCTION: 


    BiPredicate:

        - We have 2 inputs to your lambda expression and we would want to return boolean;

        - Has one abstract method test();


        BiPredicate<Integer, String> biPredicate = (number, str) -> number < 10 && str.length() > 5;

        System.out.println(biPredicate.test(7, "testString"));


    BiFunction:

        - Takes 2 inputs and return 1 value back;

        - You need to specify a Return Type;

        - Has 1 abstract method apply();




        BiFunction<Integer, String, String> biFunction = (number, str) -> number + " " +  str;

        System.out.println(biFunction.apply(7, "test"));


    BiConsumer:

        - BiConsumer takes 2 inputs and it consumes it, does not return anything back;

        - Has 1 abstract method accept();


        BiConsumer<String, String> biConsumer = (s1, s2) -> {
            System.out.println(s1);
            System.out.println(s2);
        };

        biConsumer.accept("15", "in28minutes");




    => When you create Lambda Expression, you can use this specific interfaces to represent that specific Lambda Expression;


    
    PrimitiveFunctional:

        - IntBinaryOperator

        - IntConsumer

        - IntFunction 

        - IntPredicate

        - IntSupplier 

        - IntToDoubleFunction

        - IntToLongFunction

        - IntUnaryOperator



        IntToDoubleFunction intToDoubleFunction = (x) -> x;

        System.out.println(intToDoubleFunction.applyAsDouble(5));


        - An important thing is, wherenever we are doing things with wrapper classes, boxing and unboxing comes 
          into picture and that's's inefficient (неэффективно). 

        - So, if you have a set of primitives and you'd want to play around them using Lambda Expressions,
          it's better to use Primitive Lambda Expressions;


        => Important thing that now all the operations are Primitive Operations, so there is no chance of boxing,
           auto-boxing, and all those performance kind of issues coming in;

        - Inside the List we can only have Wrapper-class elements or Wrapper-class Objects.

        - Whenever you're playing with Primitives, you should prefer the Primitive Operations.




METHOD REFERENCES:


        List<String> courses = List.of("Spring", "Spring Boot", "API",
                "Microservices", "AWS", "PCF", "Azure",
                "Docker", "Kubernetes");

        courses.stream()
                .map(String::toUpperCase)
                .forEach(System.out::println);


        
        -  For each elements inside the stream, the System.out.println would be called with that specific element passed 
           as a parameter.


        - We also saw the fact that we can actually create a static method in here and call it also from here:


            public class FP03MethodReferences {

                @SuppressWarnings("unused")
                public static void main(String[] args) {

                    List<String> courses = List.of("Spring", "Spring Boot", "API",
                            "Microservices", "AWS", "PCF", "Azure",
                            "Docker", "Kubernetes");

                    courses.stream()
                            .map(String::toUpperCase)
                            .forEach(FP03MethodReferences::print);
                }
                
                private static void print(String str) {
                    System.out.println(str);
                }
            }



        - The Interesting thing that you can also use Method References to call things on a specific object;

        - Also you can use Method References for Constructor References:


            Supplier<String>  supplier  =  ()  -> new String();

                        <=>

             Supplier<String>  supplier  = String::new;


        - You can use this to create new Objects;




ALLMATCH, NONEMATCH, ANYMATCH:


        - We want to ind out, if all the courses have a review score greater than 90:


            Predicate<Course> reviewScoreGreaterThan95Predicate = course -> course.getReviewScore() > 95;

            Predicate<Course> reviewScoreGreaterThan90Predicate = course -> course.getReviewScore() > 90;

            Predicate<Course> reviewScoreLessThan90Predicate = course -> course.getReviewScore() < 90;

            System.out.println(courses.stream()
                    .allMatch(reviewScoreGreaterThan90Predicate));

            System.out.println(courses.stream()
                    .noneMatch(reviewScoreGreaterThan95Predicate));

            System.out.println(courses.stream()
                    .noneMatch(reviewScoreLessThan90Predicate));

            System.out.println(courses.stream()
                    .anyMatch(reviewScoreGreaterThan90Predicate));


        - allMatch() returns a true, if every element in this stream matches the condition;

        - noneMatch() returns true, if no elements in the stream matches this condition;

        - anyMatch() returns true, if at least one element in the stream matches that specific condition;




SORTING. CREATING COMPARATORS:


        - For sorting stream we need sorted() and pass in a Comparator:


                Comparator<Course> comparingByNumberOfStudents = Comparator.comparing(Course::getNumberOfStudents);

                System.out.println(courses.stream()
                        .sorted(comparingByNumberOfStudents)
                        .collect(Collectors.toList()));


        - Comparing by Number Of Students Deceasing using reversed() and using no-aitoboxing primitive Comparing:


                Comparator<Course> comparingByNoOfStudentsDecreasing = Comparator.comparingInt(Course::getNumberOfStudents).reversed();

                System.out.println(courses.stream()
                .sorted(comparingByNoOfStudentsDecreasing)
                .collect(Collectors.toList()));


        - If Course has the same number of Students use thenComparing():


                Comparator<Course>  comparingByNumberOfStudentsAndReviews = Comparator.comparing(Course::getNumberOfStudents)
                        .thenComparing(Course::getReviewScore)
                        .reversed();

                System.out.println(courses.stream()
                        .sorted(comparingByNumberOfStudentsAndReviews)
                        .collect(Collectors.toList()));




SKIP, LIMIT, TAKEWHILE, DROPWHILE:



        - Let's say, I don't want a complete List of Courses, so here, when I do a sort, I want to pick up only
          the first five, the top 5 courses:

        - The way I can do that is by using a Limit - I can take only first 5 results:


              System.out.println(courses.stream()
                .sorted(comparingByNumberOfStudentsAndReviews)
                .limit(5)
                .collect(Collectors.toList()));










